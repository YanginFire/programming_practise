Пункты с 1 по 7 реализованы в файлах client.py и server.py
2 пункт. Клиент вводит exit и разрывает соединение

![image](https://user-images.githubusercontent.com/58771506/135522962-6e35f0a1-930d-4c8c-824f-cebdc533c5c9.png)

3 пункт. Сервер продолжает слушать и можно подключиться повторно. Два клиента подключились и разорвали соединение

![image](https://user-images.githubusercontent.com/58771506/135523398-2f5d4660-0d15-47c7-a8c2-89aec650d32a.png)

4 пункт. номер порта и имя хоста (для клиента) спрашивается у пользователя. Безопасный ввод данных реализован модулем getpass и значения по умолчанию при пустом вводе.

![image](https://user-images.githubusercontent.com/58771506/135524586-038bb411-beaa-4819-a2c7-101ba040a8a3.png)

![image](https://user-images.githubusercontent.com/58771506/135524849-c58d52aa-2c17-45d4-84fe-10e619fb3f35.png)

при некорректном вводе ip или port соединение просто не установится и выведется ошибка, как таковая проверка ввода и не нужна.

5 пункт. Модифицировать код сервера таким образом, чтобы все служебные сообщения выводились не в консоль, а в специальный лог-файл. Используем модуль sys и изменяем файл вывода на наш файл.

![image](https://user-images.githubusercontent.com/58771506/135525100-b618bcd3-e60f-4e18-a733-b3d6528e7b5a.png)

![image](https://user-images.githubusercontent.com/58771506/135525173-43af869a-18d9-4690-aa00-8766258ee931.png)

![image](https://user-images.githubusercontent.com/58771506/135525799-c6aca231-2193-411e-898d-3ad565f69b5b.png)

![image](https://user-images.githubusercontent.com/58771506/135525827-e4664941-3ae2-414b-b2fa-084cc0e88cd5.png)

6 пункт. Модифицируйте код сервера таким образом, чтобы он автоматически изменял номер порта, если он уже занят. Сервер должен выводить в консоль номер порта, который он слушает.

![image](https://user-images.githubusercontent.com/58771506/135526072-9d65b91e-d8ef-47b1-baf0-ed9e407df624.png)

![image](https://user-images.githubusercontent.com/58771506/135526352-d7ac508b-bb00-4aba-94b7-16fc7bd59016.png)

7 пункт. Сервер идентификации. Запросили у пользователя имя

![image](https://user-images.githubusercontent.com/58771506/135527526-f94e9c38-a212-4c24-a55a-27629b0fa9bb.png)

Записали имя пользователя и IP в файл

![image](https://user-images.githubusercontent.com/58771506/135527626-ef497bb6-f76c-47c5-9490-9d4e066e8fbd.png)

Теперь при повторном подключении сервер нас поприветствует

![image](https://user-images.githubusercontent.com/58771506/135527864-72390b36-7287-4143-8e7c-cf403f082c88.png)


Пункты с 8 по 10 реализованы в файлах client.py и server.py

8 пункт. Реализовать сервер аутентификации. Похоже на предыдущее задание, но вместе с именем пользователя сервер отслеживает и проверяет пароли. Дополнительные баллы за безопасное хранение паролей. Дополнительные баллы за поддержание сессии на основе токена наподобие cookies
При первом подключении сревер попросил придумать пароль, далее он сохранил пароль и уже предложил авторизоваться, после авторизации. Пароли в файлах хранятся в хешированном виде с ипользованием алгоритма шифрования md5. При авторизации сервер отправляет клиенту токен, который действует одну сессию, при отправке сообщения клиентом, к нему добавляется токен, сервер проверяет верен ли токен, если токен верен, сервер обрабатывает сообщение. информация о логине/пароле сохраняется в зашифрованном виде в csv файл

![image](https://user-images.githubusercontent.com/58771506/135528732-f6243c2d-335f-4d0b-83bf-5ab610a30d75.png)

![image](https://user-images.githubusercontent.com/58771506/135529225-501547ed-91c8-4c6e-91fc-8d85c47480d1.png)

теперь сервер видит, что клиент зарегистрировался и авторизовался и может обмениваться с ним сообщениями

![image](https://user-images.githubusercontent.com/58771506/135529361-69df13c1-456f-4b7d-a242-5204239a3b1b.png)

9 пункт. Напишите вспомогательные функции, которые реализуют отправку и принятие текстовых сообщений в сокет. Функция отправки должна дополнять сообщение заголовком фиксированной длины, в котором содержится информация о длине сообщения. Функция принятия должна читать сообщение с учетом заголовка. В дополнении реализуйте преобразование строки в байтовый массив и обратно в этих же функциях. Дополнително оценивается, если эти функции будут реализованы как унаследованное расширение класса socket библиотеки socket.

работа отправки/ приемки сообщений приведена в пункте 8, там можно увидеть, что выводится длина сообщений, а сообщения передаются как байтовые массивы, причем вспомогательные куски на экран не выводятся. Функции реализованы отдельно и созданы как унаследованное расширение класса socket.
Функции приема отправки клиента

![image](https://user-images.githubusercontent.com/58771506/135529682-6ae57e55-18cb-41d3-a252-92ef1c314113.png)

Функции приема отправки сервера

![image](https://user-images.githubusercontent.com/58771506/135529955-b520a1f4-1feb-4bfb-a8c0-35264388db19.png)

10 пункт. Дополните код клиента и сервера таким образом, чтобы они могли посылать друг другу множественные сообщения один в ответ на другое.
Как видим сервер и клиент могут переписываться последовательно. Слева сообщения сервера, справа клиента.

![image](https://user-images.githubusercontent.com/58771506/135530364-bb38469b-f60c-47a9-9ff9-9bb89102d807.png)

Если клиент отсоединится сервер будет ждать новое подключение.

![image](https://user-images.githubusercontent.com/58771506/135530585-05f45748-e6c0-4a33-982d-3b473533f78e.png)

