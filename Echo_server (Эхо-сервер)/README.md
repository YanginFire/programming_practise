Пункты с 1 по 7 реализованы в файлах client.py и server.py
2 пункт. Клиент вводит exit и разрывает соединение

![Screenshot_1](https://user-images.githubusercontent.com/90453727/138608410-2b14a3c9-625f-4c31-8511-17f528f369cf.jpg)


3 пункт. Сервер продолжает слушать и можно подключиться повторно. Два клиента подключились и разорвали соединение

![Screenshot_2](https://user-images.githubusercontent.com/90453727/138608447-e58dcdce-95de-4386-8fb8-3b9d991b7e95.png)


4 пункт. номер порта и имя хоста (для клиента) спрашивается у пользователя. Безопасный ввод данных реализован модулем getpass и значения по умолчанию при пустом вводе.

![Screenshot_3](https://user-images.githubusercontent.com/90453727/138608471-a5001c36-d706-43d6-bc52-d868e533575e.jpg)

![image](https://user-images.githubusercontent.com/58771506/135524849-c58d52aa-2c17-45d4-84fe-10e619fb3f35.png)

при некорректном вводе ip или port соединение просто не установится и выведется ошибка, как таковая проверка ввода и не нужна.

5 пункт. Модифицировать код сервера таким образом, чтобы все служебные сообщения выводились не в консоль, а в специальный лог-файл. Используем модуль sys и изменяем файл вывода на наш файл.

![image](https://user-images.githubusercontent.com/58771506/135525100-b618bcd3-e60f-4e18-a733-b3d6528e7b5a.png)

![image](https://user-images.githubusercontent.com/58771506/135525173-43af869a-18d9-4690-aa00-8766258ee931.png)

![image](https://user-images.githubusercontent.com/58771506/135525799-c6aca231-2193-411e-898d-3ad565f69b5b.png)

![image](https://user-images.githubusercontent.com/58771506/135525827-e4664941-3ae2-414b-b2fa-084cc0e88cd5.png)

6 пункт. Модифицируйте код сервера таким образом, чтобы он автоматически изменял номер порта, если он уже занят. Сервер должен выводить в консоль номер порта, который он слушает.

![image](https://user-images.githubusercontent.com/58771506/135526072-9d65b91e-d8ef-47b1-baf0-ed9e407df624.png)

![Screenshot_4](https://user-images.githubusercontent.com/90453727/138608509-ac8dbc28-7979-412c-885e-15013bfd0058.png)


7 пункт. Сервер идентификации. Запросили у пользователя имя

![Screenshot_5](https://user-images.githubusercontent.com/90453727/138608522-03f5b152-ab5f-4b1e-b4db-cca168237f61.jpg)

Записали имя пользователя и IP в файл

![Screenshot_1](https://user-images.githubusercontent.com/90453727/138608601-4a4709e9-77cc-4481-afd0-a1e50ce1d688.png)

Теперь при повторном подключении сервер нас поприветствует

![Screenshot_3](https://user-images.githubusercontent.com/90453727/138608640-65ad076c-59b7-4281-9c1f-b1d77f22e3c4.jpg)


Пункты с 8 по 10 реализованы в файлах client.py и server.py

8 пункт. Реализовать сервер аутентификации. Похоже на предыдущее задание, но вместе с именем пользователя сервер отслеживает и проверяет пароли. Дополнительные баллы за безопасное хранение паролей. Дополнительные баллы за поддержание сессии на основе токена наподобие cookies
При первом подключении сревер попросил придумать пароль, далее он сохранил пароль и уже предложил авторизоваться, после авторизации. Пароли в файлах хранятся в хешированном виде с ипользованием алгоритма шифрования md5. При авторизации сервер отправляет клиенту токен, который действует одну сессию, при отправке сообщения клиентом, к нему добавляется токен, сервер проверяет верен ли токен, если токен верен, сервер обрабатывает сообщение. информация о логине/пароле сохраняется в зашифрованном виде в csv файл

![Screenshot_4](https://user-images.githubusercontent.com/90453727/138608657-871aa21c-ddd5-4be4-b470-949e306d9aee.png)

![image](https://user-images.githubusercontent.com/58771506/135529225-501547ed-91c8-4c6e-91fc-8d85c47480d1.png)

теперь сервер видит, что клиент зарегистрировался и авторизовался и может обмениваться с ним сообщениями

![image](https://user-images.githubusercontent.com/58771506/135529361-69df13c1-456f-4b7d-a242-5204239a3b1b.png)

9 пункт. Напишите вспомогательные функции, которые реализуют отправку и принятие текстовых сообщений в сокет. Функция отправки должна дополнять сообщение заголовком фиксированной длины, в котором содержится информация о длине сообщения. Функция принятия должна читать сообщение с учетом заголовка. В дополнении реализуйте преобразование строки в байтовый массив и обратно в этих же функциях. Дополнително оценивается, если эти функции будут реализованы как унаследованное расширение класса socket библиотеки socket.

работа отправки/ приемки сообщений приведена в пункте 8, там можно увидеть, что выводится длина сообщений, а сообщения передаются как байтовые массивы, причем вспомогательные куски на экран не выводятся. Функции реализованы отдельно и созданы как унаследованное расширение класса socket.
Функции приема отправки клиента

![image](https://user-images.githubusercontent.com/58771506/135529682-6ae57e55-18cb-41d3-a252-92ef1c314113.png)

Функции приема отправки сервера

![image](https://user-images.githubusercontent.com/58771506/135529955-b520a1f4-1feb-4bfb-a8c0-35264388db19.png)

10 пункт. Дополните код клиента и сервера таким образом, чтобы они могли посылать друг другу множественные сообщения один в ответ на другое.
Как видим сервер и клиент могут переписываться последовательно. Слева сообщения сервера, справа клиента.

![Screenshot_7](https://user-images.githubusercontent.com/90453727/138608675-7f79392a-3c64-4297-b05e-62e32bf05db1.png)


Если клиент отсоединится сервер будет ждать новое подключение.
